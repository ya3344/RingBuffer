#include "pch.h"
#include "RingBuffer.h"

int RingBuffer::Enqueue(const char* inputData, int dataSize)
{
	int count = 0;

	while (dataSize != 0)
	{
		// 데이터 꽉 참
		if ((mWritePos + 1) % MAX_BUFFER_SIZE == mReadPos)
		{
			return count;
		}
		mData[mWritePos] = *inputData;
		mWritePos = (mWritePos + 1) % MAX_BUFFER_SIZE;

		++count;
		++inputData;
		--dataSize;
		++mUseCount;

		// 에러 처리 사용한 Buffer 한계치 초과
		if (mUseCount >= MAX_BUFFER_SIZE)
			return USE_COUNT_OVER_FLOW;
	}

	return count;
}

/*
* Peek 체크 후 디큐 진행.(검증용 함수)
* Peek 함수가 선 호출되어야 함.
*/
int RingBuffer::ConfirmDequeue(char* outputData, int dataSize)
{
	int count = 0;
	int readPos = mReadPos;
	bool isPosInit = false;
	int rewindCount = 0;
	char compareData[100] = { 0, };
	int totalCount = 0;

	while (dataSize != 0)
	{
		//데이터 비어 있음
		if (readPos == mWritePos)
		{
			//readPos가 배열 끝에서 시작으로 넘어갈경우
			if (rewindCount > 0)
			{
				memcpy(compareData, mData + mReadPos, count);
				memcpy(compareData + count, mData, rewindCount);
			}
			else
				memcpy(compareData, mData + mReadPos, count);

			// Peek함수 호출 후 Output 결과값과 비교 
			if (memcmp(compareData, outputData, strlen(outputData)) == 0)
			{
				mReadPos = readPos;
				totalCount = count + rewindCount;
				return totalCount;
			}
			else
			{
				return -1;
			}
		}

		readPos = (readPos + 1) % MAX_BUFFER_SIZE;

		if (isPosInit == true)
			++rewindCount;
		else
			++count;

		if (readPos == 0)
			isPosInit = true;

		--dataSize;
	}

	if (rewindCount > 0)
	{
		memcpy(compareData, mData + mReadPos, count);
		memcpy(compareData + count, mData, rewindCount);
	}
	else
		memcpy(compareData, mData + mReadPos, count);

	// Peek함수 호출 후 Output 결과값과 비교 
	if (memcmp(compareData, outputData, strlen(outputData)) == 0)
	{
		mReadPos = readPos;
		totalCount = count + rewindCount;
		return totalCount;
	}
	else
	{
		return -1;
	}

	return 0;
}

int RingBuffer::Peek(char* outputData, int dataSize)
{
	int count = 0;
	int readPos = mReadPos;
	bool isPosInit = false;
	int rewindCount = 0;
	int totalCount = 0;

	while (dataSize != 0)
	{
		//데이터 비어 있음
		if (readPos == mWritePos)
		{
			//readPos가 배열 끝에서 시작으로 넘어갈경우
			if (rewindCount > 0)
			{
				memcpy(outputData, mData + mReadPos, count);
				memcpy(outputData + count, mData, rewindCount);
			}
			else
				memcpy(outputData, mData + mReadPos, count);

			totalCount = count + rewindCount;

			return totalCount;
		}

		readPos = (readPos + 1) % MAX_BUFFER_SIZE;

		if (isPosInit == true)
			++rewindCount;
		else
			++count;

		if (readPos == 0)
			isPosInit = true;

		--dataSize;
	}

	//readPos가 배열 끝에서 시작으로 넘어갈경우
	if (rewindCount > 0)
	{
		memcpy(outputData, mData + mReadPos, count);
		memcpy(outputData + count, mData, rewindCount);
	}
	else
		memcpy(outputData, mData + mReadPos, count);

	totalCount = count + rewindCount;

	return totalCount;
}

int RingBuffer::Dequeue(char* outputData, int dataSize)
{
	int count = 0;
	int readPos = mReadPos;
	bool isPosInit = false;
	int rewindCount = 0;
	int totalCount = 0;

	while (dataSize != 0)
	{
		//데이터 비어 있음
		if (readPos == mWritePos)
		{
			//readPos가 배열 끝에서 시작으로 넘어갈경우
			if (rewindCount > 0)
			{
				memcpy(outputData, mData + mReadPos, count);
				memcpy(outputData + count, mData, rewindCount);
			}
			else
				memcpy(outputData, mData + mReadPos, count);

			//읽은 데이터 총계를 더한다.
			totalCount = count + rewindCount;

			//읽은 데이터 위치 갱신
			mReadPos = readPos;

			//읽은 만큼 UseCount 감소
			mUseCount = mUseCount - totalCount;
			if (mUseCount < 0)
				return USE_COUNT_UNDER_FLOW;

			return totalCount;
		}

		readPos = (readPos + 1) % MAX_BUFFER_SIZE;

		if (isPosInit == true)
			++rewindCount;
		else
			++count;

		if (readPos == 0)
			isPosInit = true;

		--dataSize;
	}

	//readPos가 배열 끝에서 시작으로 넘어갈경우
	if (rewindCount > 0)
	{
		memcpy(outputData, mData + mReadPos, count);
		memcpy(outputData + count, mData, rewindCount);
	}
	else
		memcpy(outputData, mData + mReadPos, count);

	//읽은 데이터 총계를 더한다.
	totalCount = count + rewindCount;

	//읽은 데이터 위치 갱신
	mReadPos = readPos;

	//읽은 만큼 UseCount 감소
	mUseCount = mUseCount - totalCount;
	if (mUseCount < 0)
		return USE_COUNT_UNDER_FLOW;

	return totalCount;
}

int RingBuffer::GetFreeSize() const
{
	int freeSize = MAX_BUFFER_SIZE - mUseCount;

	freeSize -= 1; // 1byte는 사용 못하는 공간

	return freeSize;
}

int RingBuffer::GetUseSize() const
{
	return mUseCount;
}

bool RingBuffer::MoveReadPos(const int readSize)
{
	mReadPos += readSize;
	mReadPos %= MAX_BUFFER_SIZE;
	mUseCount -= readSize;

	// 에러처리
	if (mUseCount < 0)
		return false;

	return true;
}
